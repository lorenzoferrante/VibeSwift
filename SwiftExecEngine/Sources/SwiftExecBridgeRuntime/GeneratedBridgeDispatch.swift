import Foundation
import SwiftExecDiagnostics
import SwiftExecSemantic

// This file is generated by Tools/SwiftExecWrapperGen in production.
public enum GeneratedBridgeDispatch {
    public static func invoke(
        symbolID: SymbolID,
        receiver: RuntimeValue?,
        args: [RuntimeValue],
        printSink: (@Sendable (String) -> Void)?
    ) throws -> RuntimeValue? {
        switch symbolID {
        case GeneratedSymbolTable.swiftPrint:
            guard args.count == 1 else {
                throw RuntimeError(message: "Swift.print expects 1 argument", symbolID: symbolID)
            }
            let rendered = args[0].stringValue ?? String(describing: args[0])
            printSink?(rendered)
            return RuntimeValue.none

        case GeneratedSymbolTable.stringUppercased:
            guard let base = receiver?.stringValue else {
                throw RuntimeError(message: "uppercased requires String receiver", symbolID: symbolID)
            }
            guard args.isEmpty else {
                throw RuntimeError(message: "uppercased expects 0 arguments", symbolID: symbolID)
            }
            return .string(base.uppercased())

        case GeneratedSymbolTable.stringLowercased:
            guard let base = receiver?.stringValue else {
                throw RuntimeError(message: "lowercased requires String receiver", symbolID: symbolID)
            }
            guard args.isEmpty else {
                throw RuntimeError(message: "lowercased expects 0 arguments", symbolID: symbolID)
            }
            return .string(base.lowercased())

        case GeneratedSymbolTable.stringContains:
            guard let base = receiver?.stringValue else {
                throw RuntimeError(message: "contains requires String receiver", symbolID: symbolID)
            }
            guard args.count == 1, let needle = args[0].stringValue else {
                throw RuntimeError(message: "contains expects one String argument", symbolID: symbolID)
            }
            return .bool(base.contains(needle))

        case GeneratedSymbolTable.intInit:
            guard args.count == 1, let value = args[0].int64Value else {
                throw RuntimeError(message: "Int.init expects one numeric argument", symbolID: symbolID)
            }
            return .int64(value)

        case GeneratedSymbolTable.doubleInit:
            guard args.count == 1, let value = args[0].doubleValue else {
                throw RuntimeError(message: "Double.init expects one numeric argument", symbolID: symbolID)
            }
            return .double(value)

        case GeneratedSymbolTable.boolInit:
            guard args.count == 1, let value = args[0].boolValue else {
                throw RuntimeError(message: "Bool.init expects one bool-like argument", symbolID: symbolID)
            }
            return .bool(value)

        case GeneratedSymbolTable.dateNow:
            guard args.isEmpty else {
                throw RuntimeError(message: "Date.now expects 0 arguments", symbolID: symbolID)
            }
            return .native(NativeBox(Date.now))

        case GeneratedSymbolTable.textInit:
            return try makeTextNode(args: args, symbolID: symbolID)
        case GeneratedSymbolTable.buttonInit:
            return try makeButtonNode(args: args, symbolID: symbolID)
        case GeneratedSymbolTable.vStackInit:
            return try makeStackNode(type: "VStack", args: args, symbolID: symbolID)
        case GeneratedSymbolTable.hStackInit:
            return try makeStackNode(type: "HStack", args: args, symbolID: symbolID)
        case GeneratedSymbolTable.spacerInit:
            return try makeSpacerNode(args: args, symbolID: symbolID)
        case GeneratedSymbolTable.imageInit:
            return try makeImageNode(args: args, symbolID: symbolID)
        case GeneratedSymbolTable.textFieldInit:
            return try makeTextFieldNode(args: args, symbolID: symbolID)
        case GeneratedSymbolTable.toggleInit:
            return try makeToggleNode(args: args, symbolID: symbolID)

        case GeneratedSymbolTable.paddingModifier:
            return try applyPadding(args: args, symbolID: symbolID)
        case GeneratedSymbolTable.fontModifier:
            return try applyFont(args: args, symbolID: symbolID)
        case GeneratedSymbolTable.foregroundStyleModifier:
            return try applyForegroundStyle(args: args, symbolID: symbolID)
        case GeneratedSymbolTable.frameModifier:
            return try applyFrame(args: args, symbolID: symbolID)
        case GeneratedSymbolTable.backgroundModifier:
            return try applyBackground(args: args, symbolID: symbolID)

        case GeneratedSymbolTable.onTapHook:
            return try applyTapHook(args: args, symbolID: symbolID)
        case GeneratedSymbolTable.onAppearHook:
            return try applyAppearHook(args: args, symbolID: symbolID)
        case GeneratedSymbolTable.onChangeHook:
            return try applyChangeHook(args: args, symbolID: symbolID)

        case GeneratedSymbolTable.stateInit:
            guard args.isEmpty else {
                throw RuntimeError(message: "State.init expects 0 arguments", symbolID: symbolID)
            }
            return .native(NativeBox(sharedStateReceiverToken))
        case GeneratedSymbolTable.stateGet:
            try validateStateReceiver(receiver, symbolID: symbolID)
            guard args.count == 1, let path = args[0].stringValue else {
                throw RuntimeError(message: "state.get expects one String path", symbolID: symbolID)
            }
            let context = try requireScriptContext(symbolID: symbolID)
            return context.stateGet(path)
        case GeneratedSymbolTable.stateSet:
            try validateStateReceiver(receiver, symbolID: symbolID)
            guard args.count == 2, let path = args[0].stringValue else {
                throw RuntimeError(message: "state.set expects path and value", symbolID: symbolID)
            }
            let context = try requireScriptContext(symbolID: symbolID)
            context.stateSet(path, args[1])
            return .none
        case GeneratedSymbolTable.stateBind:
            try validateStateReceiver(receiver, symbolID: symbolID)
            guard args.count == 1, let path = args[0].stringValue else {
                throw RuntimeError(message: "state.bind expects one String path", symbolID: symbolID)
            }
            let context = try requireScriptContext(symbolID: symbolID)
            return context.stateBind(path)

        case GeneratedSymbolTable.opAdd:
            return try evaluateAdd(lhs: args[safe: 0], rhs: args[safe: 1], symbolID: symbolID)
        case GeneratedSymbolTable.opSubtract:
            return try evaluateNumeric(lhs: args[safe: 0], rhs: args[safe: 1], symbolID: symbolID, intOp: -, doubleOp: -)
        case GeneratedSymbolTable.opMultiply:
            return try evaluateNumeric(lhs: args[safe: 0], rhs: args[safe: 1], symbolID: symbolID, intOp: *, doubleOp: *)
        case GeneratedSymbolTable.opDivide:
            return try evaluateDivide(lhs: args[safe: 0], rhs: args[safe: 1], symbolID: symbolID)
        case GeneratedSymbolTable.opEqual:
            return try evaluateComparison(lhs: args[safe: 0], rhs: args[safe: 1], symbolID: symbolID, comparator: ==)
        case GeneratedSymbolTable.opLess:
            return try evaluateComparison(lhs: args[safe: 0], rhs: args[safe: 1], symbolID: symbolID, comparator: <)
        case GeneratedSymbolTable.opGreater:
            return try evaluateComparison(lhs: args[safe: 0], rhs: args[safe: 1], symbolID: symbolID, comparator: >)
        case GeneratedSymbolTable.opLessOrEqual:
            return try evaluateComparison(lhs: args[safe: 0], rhs: args[safe: 1], symbolID: symbolID, comparator: <=)
        case GeneratedSymbolTable.opGreaterOrEqual:
            return try evaluateComparison(lhs: args[safe: 0], rhs: args[safe: 1], symbolID: symbolID, comparator: >=)
        case GeneratedSymbolTable.opAnd:
            return try evaluateBoolOperator(lhs: args[safe: 0], rhs: args[safe: 1], symbolID: symbolID, op: { $0 && $1 })
        case GeneratedSymbolTable.opOr:
            return try evaluateBoolOperator(lhs: args[safe: 0], rhs: args[safe: 1], symbolID: symbolID, op: { $0 || $1 })

        default:
            return nil
        }
    }
}

private extension GeneratedBridgeDispatch {
    static func requireScriptContext(symbolID: SymbolID) throws -> BridgeScriptContext {
        guard let context = BridgeRuntime.currentScriptContext else {
            throw RuntimeError(message: "State runtime is unavailable outside live renderer execution", symbolID: symbolID)
        }
        return context
    }

    static func validateStateReceiver(_ receiver: RuntimeValue?, symbolID: SymbolID) throws {
        guard let receiver else {
            // Global-style stateGet/stateSet/stateBind is also supported.
            return
        }
        guard case let .native(box) = receiver, box.value is StateReceiverToken else {
            throw RuntimeError(message: "state.* methods require a State receiver", symbolID: symbolID)
        }
    }

    static func makeTextNode(args: [RuntimeValue], symbolID: SymbolID) throws -> RuntimeValue {
        guard !args.isEmpty else {
            throw RuntimeError(message: "Text expects at least one argument", symbolID: symbolID)
        }
        let text = args[0].stringValue ?? String(describing: args[0])
        let explicitID = args[safe: 1]?.stringValue
        return try makeNode(
            type: "Text",
            props: ["text": .string(text)],
            children: [],
            explicitID: explicitID
        )
    }

    static func makeButtonNode(args: [RuntimeValue], symbolID: SymbolID) throws -> RuntimeValue {
        guard args.count >= 2,
              let title = args[0].stringValue,
              let actionID = args[1].stringValue else {
            throw RuntimeError(message: "Button expects title and actionID", symbolID: symbolID)
        }
        let explicitID = args[safe: 2]?.stringValue
        let tap = makeEvent(event: "tap", actionID: actionID, path: nil)
        return try makeNode(
            type: "Button",
            props: ["title": .string(title)],
            children: [],
            events: [tap],
            explicitID: explicitID
        )
    }

    static func makeStackNode(type: String, args: [RuntimeValue], symbolID: SymbolID) throws -> RuntimeValue {
        var spacing = 0.0
        var childStart = 0
        if let first = args.first, let numeric = first.doubleValue {
            spacing = numeric
            childStart = 1
        }
        let childValues = Array(args.dropFirst(childStart))
        return try makeNode(
            type: type,
            props: ["spacing": .double(spacing)],
            children: childValues
        )
    }

    static func makeSpacerNode(args: [RuntimeValue], symbolID: SymbolID) throws -> RuntimeValue {
        let explicitID = args[safe: 0]?.stringValue
        return try makeNode(type: "Spacer", props: [:], children: [], explicitID: explicitID)
    }

    static func makeImageNode(args: [RuntimeValue], symbolID: SymbolID) throws -> RuntimeValue {
        guard args.count >= 1, let name = args[0].stringValue else {
            throw RuntimeError(message: "Image expects a system/image name", symbolID: symbolID)
        }
        let explicitID = args[safe: 1]?.stringValue
        return try makeNode(
            type: "Image",
            props: ["name": .string(name)],
            children: [],
            explicitID: explicitID
        )
    }

    static func makeTextFieldNode(args: [RuntimeValue], symbolID: SymbolID) throws -> RuntimeValue {
        guard args.count >= 2, let title = args[0].stringValue else {
            throw RuntimeError(message: "TextField expects title and binding", symbolID: symbolID)
        }
        let binding = try normalizeBinding(args[1], symbolID: symbolID)
        let explicitID = args[safe: 2]?.stringValue
        return try makeNode(
            type: "TextField",
            props: [
                "title": .string(title),
                "text": binding
            ],
            children: [],
            explicitID: explicitID
        )
    }

    static func makeToggleNode(args: [RuntimeValue], symbolID: SymbolID) throws -> RuntimeValue {
        guard args.count >= 2, let title = args[0].stringValue else {
            throw RuntimeError(message: "Toggle expects title and binding", symbolID: symbolID)
        }
        let binding = try normalizeBinding(args[1], symbolID: symbolID)
        let explicitID = args[safe: 2]?.stringValue
        return try makeNode(
            type: "Toggle",
            props: [
                "title": .string(title),
                "isOn": binding
            ],
            children: [],
            explicitID: explicitID
        )
    }

    static func applyPadding(args: [RuntimeValue], symbolID: SymbolID) throws -> RuntimeValue {
        guard let node = args[safe: 0] else {
            throw RuntimeError(message: "padding expects node argument", symbolID: symbolID)
        }
        let amount = args[safe: 1] ?? .double(8)
        return try appendModifier(node, type: "padding", params: ["value": amount], symbolID: symbolID)
    }

    static func applyFont(args: [RuntimeValue], symbolID: SymbolID) throws -> RuntimeValue {
        guard let node = args[safe: 0], let font = args[safe: 1]?.stringValue else {
            throw RuntimeError(message: "font expects node and font name", symbolID: symbolID)
        }
        return try appendModifier(node, type: "font", params: ["value": .string(font)], symbolID: symbolID)
    }

    static func applyForegroundStyle(args: [RuntimeValue], symbolID: SymbolID) throws -> RuntimeValue {
        guard let node = args[safe: 0], let style = args[safe: 1]?.stringValue else {
            throw RuntimeError(message: "foregroundStyle expects node and style", symbolID: symbolID)
        }
        return try appendModifier(node, type: "foregroundStyle", params: ["value": .string(style)], symbolID: symbolID)
    }

    static func applyFrame(args: [RuntimeValue], symbolID: SymbolID) throws -> RuntimeValue {
        guard let node = args[safe: 0] else {
            throw RuntimeError(message: "frame expects node argument", symbolID: symbolID)
        }
        var params: [String: RuntimeValue] = [:]
        if let width = args[safe: 1]?.doubleValue {
            params["width"] = .double(width)
        }
        if let height = args[safe: 2]?.doubleValue {
            params["height"] = .double(height)
        }
        return try appendModifier(node, type: "frame", params: params, symbolID: symbolID)
    }

    static func applyBackground(args: [RuntimeValue], symbolID: SymbolID) throws -> RuntimeValue {
        guard let node = args[safe: 0], let background = args[safe: 1]?.stringValue else {
            throw RuntimeError(message: "background expects node and style", symbolID: symbolID)
        }
        return try appendModifier(node, type: "background", params: ["value": .string(background)], symbolID: symbolID)
    }

    static func applyTapHook(args: [RuntimeValue], symbolID: SymbolID) throws -> RuntimeValue {
        guard let node = args[safe: 0], let actionID = args[safe: 1]?.stringValue else {
            throw RuntimeError(message: "onTap expects node and actionID", symbolID: symbolID)
        }
        return try appendEvent(node, event: "tap", actionID: actionID, path: nil, symbolID: symbolID)
    }

    static func applyAppearHook(args: [RuntimeValue], symbolID: SymbolID) throws -> RuntimeValue {
        guard let node = args[safe: 0], let actionID = args[safe: 1]?.stringValue else {
            throw RuntimeError(message: "onAppear expects node and actionID", symbolID: symbolID)
        }
        return try appendEvent(node, event: "onAppear", actionID: actionID, path: nil, symbolID: symbolID)
    }

    static func applyChangeHook(args: [RuntimeValue], symbolID: SymbolID) throws -> RuntimeValue {
        guard let node = args[safe: 0],
              let path = args[safe: 1]?.stringValue,
              let actionID = args[safe: 2]?.stringValue else {
            throw RuntimeError(message: "onChange expects node, path and actionID", symbolID: symbolID)
        }
        return try appendEvent(node, event: "onChange", actionID: actionID, path: path, symbolID: symbolID)
    }

    static func normalizeBinding(_ value: RuntimeValue, symbolID: SymbolID) throws -> RuntimeValue {
        if case let .dictionary(object) = value, object["$binding"]?.stringValue != nil {
            return value
        }
        if let path = value.stringValue {
            return .dictionary(["$binding": .string(path)])
        }
        throw RuntimeError(message: "Expected BindingRef(path:)", symbolID: symbolID)
    }

    static func makeNode(
        type: String,
        props: [String: RuntimeValue],
        children: [RuntimeValue],
        modifiers: [RuntimeValue] = [],
        events: [RuntimeValue] = [],
        explicitID: String? = nil
    ) throws -> RuntimeValue {
        var normalizedChildren: [RuntimeValue] = []
        normalizedChildren.reserveCapacity(children.count)
        for child in children {
            guard let node = nodeObject(from: child) else {
                throw RuntimeError(message: "\(type) children must be Node values")
            }
            normalizedChildren.append(.dictionary(node))
        }

        let childIDs = normalizedChildren.compactMap { value -> String? in
            guard case let .dictionary(object) = value else {
                return nil
            }
            return object["id"]?.stringValue
        }

        let propsSignature = props
            .keys
            .sorted()
            .map { key in "\(key)=\(props[key]?.description ?? "nil")" }
            .joined(separator: ",")
        let childSignature = childIDs.joined(separator: ",")
        let generatedID = "node-\(SymbolHasher.hash(raw: "\(type)|\(propsSignature)|\(childSignature)"))"
        let resolvedID = (explicitID?.isEmpty == false) ? explicitID! : generatedID

        var object: [String: RuntimeValue] = [
            "id": .string(resolvedID),
            "type": .string(type),
            "props": .dictionary(props),
            "children": .array(normalizedChildren),
            "modifiers": .array(modifiers),
            "events": .array(events)
        ]
        object["id"] = .string(resolvedID)
        return .dictionary(object)
    }

    static func appendModifier(
        _ value: RuntimeValue,
        type: String,
        params: [String: RuntimeValue],
        symbolID: SymbolID
    ) throws -> RuntimeValue {
        guard var object = nodeObject(from: value) else {
            throw RuntimeError(message: "\(type) modifier expects a Node argument", symbolID: symbolID)
        }
        var modifiers = object["modifiers"]?.arrayValue ?? []
        modifiers.append(makeModifier(type: type, params: params))
        object["modifiers"] = .array(modifiers)
        return .dictionary(object)
    }

    static func appendEvent(
        _ value: RuntimeValue,
        event: String,
        actionID: String,
        path: String?,
        symbolID: SymbolID
    ) throws -> RuntimeValue {
        guard var object = nodeObject(from: value) else {
            throw RuntimeError(message: "\(event) hook expects a Node argument", symbolID: symbolID)
        }
        var events = object["events"]?.arrayValue ?? []
        events.append(makeEvent(event: event, actionID: actionID, path: path))
        object["events"] = .array(events)
        return .dictionary(object)
    }

    static func makeModifier(type: String, params: [String: RuntimeValue]) -> RuntimeValue {
        .dictionary(
            [
                "type": .string(type),
                "params": .dictionary(params)
            ]
        )
    }

    static func makeEvent(event: String, actionID: String, path: String?) -> RuntimeValue {
        var payload: [String: RuntimeValue] = [
            "event": .string(event),
            "actionID": .string(actionID)
        ]
        if let path {
            payload["path"] = .string(path)
        }
        return .dictionary(payload)
    }

    static func nodeObject(from value: RuntimeValue) -> [String: RuntimeValue]? {
        guard case let .dictionary(object) = value,
              object["type"]?.stringValue != nil else {
            return nil
        }
        return object
    }

    static func evaluateAdd(lhs: RuntimeValue?, rhs: RuntimeValue?, symbolID: SymbolID) throws -> RuntimeValue {
        guard let lhs, let rhs else {
            throw RuntimeError(message: "+ expects 2 operands", symbolID: symbolID)
        }
        if let lInt = lhs.int64Value, let rInt = rhs.int64Value {
            return .int64(lInt + rInt)
        }
        if let lDouble = lhs.doubleValue, let rDouble = rhs.doubleValue {
            return .double(lDouble + rDouble)
        }
        if let lString = lhs.stringValue, let rString = rhs.stringValue {
            return .string(lString + rString)
        }
        throw RuntimeError(message: "unsupported + operands", symbolID: symbolID)
    }

    static func evaluateNumeric(
        lhs: RuntimeValue?,
        rhs: RuntimeValue?,
        symbolID: SymbolID,
        intOp: (Int64, Int64) -> Int64,
        doubleOp: (Double, Double) -> Double
    ) throws -> RuntimeValue {
        guard let lhs, let rhs else {
            throw RuntimeError(message: "operator expects 2 operands", symbolID: symbolID)
        }
        if let lInt = lhs.int64Value, let rInt = rhs.int64Value {
            return .int64(intOp(lInt, rInt))
        }
        if let lDouble = lhs.doubleValue, let rDouble = rhs.doubleValue {
            return .double(doubleOp(lDouble, rDouble))
        }
        throw RuntimeError(message: "unsupported numeric operands", symbolID: symbolID)
    }

    static func evaluateDivide(lhs: RuntimeValue?, rhs: RuntimeValue?, symbolID: SymbolID) throws -> RuntimeValue {
        guard let lhs, let rhs else {
            throw RuntimeError(message: "/ expects 2 operands", symbolID: symbolID)
        }
        if let lInt = lhs.int64Value, let rInt = rhs.int64Value {
            if rInt == 0 {
                throw RuntimeError(message: "division by zero", symbolID: symbolID)
            }
            return .int64(lInt / rInt)
        }
        if let lDouble = lhs.doubleValue, let rDouble = rhs.doubleValue {
            if rDouble == 0 {
                throw RuntimeError(message: "division by zero", symbolID: symbolID)
            }
            return .double(lDouble / rDouble)
        }
        throw RuntimeError(message: "unsupported / operands", symbolID: symbolID)
    }

    static func evaluateComparison(
        lhs: RuntimeValue?,
        rhs: RuntimeValue?,
        symbolID: SymbolID,
        comparator: (Double, Double) -> Bool
    ) throws -> RuntimeValue {
        guard let lhs, let rhs else {
            throw RuntimeError(message: "comparison expects 2 operands", symbolID: symbolID)
        }
        if let lDouble = lhs.doubleValue, let rDouble = rhs.doubleValue {
            return .bool(comparator(lDouble, rDouble))
        }
        if let lString = lhs.stringValue, let rString = rhs.stringValue {
            return .bool(comparator(Double(lString.count), Double(rString.count)))
        }
        throw RuntimeError(message: "unsupported comparison operands", symbolID: symbolID)
    }

    static func evaluateBoolOperator(
        lhs: RuntimeValue?,
        rhs: RuntimeValue?,
        symbolID: SymbolID,
        op: (Bool, Bool) -> Bool
    ) throws -> RuntimeValue {
        guard let lhs, let rhs else {
            throw RuntimeError(message: "boolean operator expects 2 operands", symbolID: symbolID)
        }
        guard let lhsBool = lhs.boolValue, let rhsBool = rhs.boolValue else {
            throw RuntimeError(message: "unsupported boolean operands", symbolID: symbolID)
        }
        return .bool(op(lhsBool, rhsBool))
    }
}

private final class StateReceiverToken {}
private let sharedStateReceiverToken = StateReceiverToken()

private extension Array {
    subscript(safe index: Int) -> Element? {
        guard indices.contains(index) else {
            return nil
        }
        return self[index]
    }
}

private extension RuntimeValue {
    var arrayValue: [RuntimeValue]? {
        if case let .array(values) = self {
            return values
        }
        return nil
    }
}
