import Foundation
import SwiftExecDiagnostics
import SwiftExecSemantic

#if canImport(SwiftUI)
import SwiftUI
#endif

// This file is generated by Tools/SwiftExecWrapperGen in production.
public enum GeneratedBridgeDispatch {
    public static func invoke(
        symbolID: SymbolID,
        receiver: RuntimeValue?,
        args: [RuntimeValue],
        printSink: (@Sendable (String) -> Void)?
    ) throws -> RuntimeValue? {
        switch symbolID {
        case GeneratedSymbolTable.swiftPrint:
            guard args.count == 1 else {
                throw RuntimeError(message: "Swift.print expects 1 argument", symbolID: symbolID)
            }
            let rendered = args[0].stringValue ?? String(describing: args[0])
            printSink?(rendered)
            return RuntimeValue.none

        case GeneratedSymbolTable.stringUppercased:
            guard let base = receiver?.stringValue else {
                throw RuntimeError(message: "uppercased requires String receiver", symbolID: symbolID)
            }
            guard args.isEmpty else {
                throw RuntimeError(message: "uppercased expects 0 arguments", symbolID: symbolID)
            }
            return .string(base.uppercased())

        case GeneratedSymbolTable.stringLowercased:
            guard let base = receiver?.stringValue else {
                throw RuntimeError(message: "lowercased requires String receiver", symbolID: symbolID)
            }
            guard args.isEmpty else {
                throw RuntimeError(message: "lowercased expects 0 arguments", symbolID: symbolID)
            }
            return .string(base.lowercased())

        case GeneratedSymbolTable.stringContains:
            guard let base = receiver?.stringValue else {
                throw RuntimeError(message: "contains requires String receiver", symbolID: symbolID)
            }
            guard args.count == 1, let needle = args[0].stringValue else {
                throw RuntimeError(message: "contains expects one String argument", symbolID: symbolID)
            }
            return .bool(base.contains(needle))

        case GeneratedSymbolTable.intInit:
            guard args.count == 1, let value = args[0].int64Value else {
                throw RuntimeError(message: "Int.init expects one numeric argument", symbolID: symbolID)
            }
            return .int64(value)

        case GeneratedSymbolTable.doubleInit:
            guard args.count == 1, let value = args[0].doubleValue else {
                throw RuntimeError(message: "Double.init expects one numeric argument", symbolID: symbolID)
            }
            return .double(value)

        case GeneratedSymbolTable.boolInit:
            guard args.count == 1, let value = args[0].boolValue else {
                throw RuntimeError(message: "Bool.init expects one bool-like argument", symbolID: symbolID)
            }
            return .bool(value)

        case GeneratedSymbolTable.dateNow:
            guard args.isEmpty else {
                throw RuntimeError(message: "Date.now expects 0 arguments", symbolID: symbolID)
            }
            return .native(NativeBox(Date.now))

        case GeneratedSymbolTable.opAdd:
            return try evaluateAdd(lhs: args[safe: 0], rhs: args[safe: 1], symbolID: symbolID)
        case GeneratedSymbolTable.opSubtract:
            return try evaluateNumeric(lhs: args[safe: 0], rhs: args[safe: 1], symbolID: symbolID, intOp: -, doubleOp: -)
        case GeneratedSymbolTable.opMultiply:
            return try evaluateNumeric(lhs: args[safe: 0], rhs: args[safe: 1], symbolID: symbolID, intOp: *, doubleOp: *)
        case GeneratedSymbolTable.opDivide:
            return try evaluateDivide(lhs: args[safe: 0], rhs: args[safe: 1], symbolID: symbolID)
        case GeneratedSymbolTable.opEqual:
            return try evaluateComparison(lhs: args[safe: 0], rhs: args[safe: 1], symbolID: symbolID, comparator: ==)
        case GeneratedSymbolTable.opLess:
            return try evaluateComparison(lhs: args[safe: 0], rhs: args[safe: 1], symbolID: symbolID, comparator: <)
        case GeneratedSymbolTable.opGreater:
            return try evaluateComparison(lhs: args[safe: 0], rhs: args[safe: 1], symbolID: symbolID, comparator: >)
        case GeneratedSymbolTable.opLessOrEqual:
            return try evaluateComparison(lhs: args[safe: 0], rhs: args[safe: 1], symbolID: symbolID, comparator: <=)
        case GeneratedSymbolTable.opGreaterOrEqual:
            return try evaluateComparison(lhs: args[safe: 0], rhs: args[safe: 1], symbolID: symbolID, comparator: >=)
        case GeneratedSymbolTable.opAnd:
            return try evaluateBoolOperator(lhs: args[safe: 0], rhs: args[safe: 1], symbolID: symbolID, op: { $0 && $1 })
        case GeneratedSymbolTable.opOr:
            return try evaluateBoolOperator(lhs: args[safe: 0], rhs: args[safe: 1], symbolID: symbolID, op: { $0 || $1 })

        case GeneratedSymbolTable.textInit:
            #if canImport(SwiftUI)
            guard args.count == 1, let value = args[0].stringValue else {
                throw RuntimeError(message: "Text.init expects one String argument", symbolID: symbolID)
            }
            let erased = AnyView(Text(value))
            return .native(NativeBox(erased))
            #else
            throw RuntimeError(message: "SwiftUI is unavailable on this platform", symbolID: symbolID)
            #endif

        default:
            return nil
        }
    }
}

private extension GeneratedBridgeDispatch {
    static func evaluateAdd(lhs: RuntimeValue?, rhs: RuntimeValue?, symbolID: SymbolID) throws -> RuntimeValue {
        guard let lhs, let rhs else {
            throw RuntimeError(message: "+ expects 2 operands", symbolID: symbolID)
        }
        if let lInt = lhs.int64Value, let rInt = rhs.int64Value {
            return .int64(lInt + rInt)
        }
        if let lDouble = lhs.doubleValue, let rDouble = rhs.doubleValue {
            return .double(lDouble + rDouble)
        }
        if let lString = lhs.stringValue, let rString = rhs.stringValue {
            return .string(lString + rString)
        }
        throw RuntimeError(message: "unsupported + operands", symbolID: symbolID)
    }

    static func evaluateNumeric(
        lhs: RuntimeValue?,
        rhs: RuntimeValue?,
        symbolID: SymbolID,
        intOp: (Int64, Int64) -> Int64,
        doubleOp: (Double, Double) -> Double
    ) throws -> RuntimeValue {
        guard let lhs, let rhs else {
            throw RuntimeError(message: "operator expects 2 operands", symbolID: symbolID)
        }
        if let lInt = lhs.int64Value, let rInt = rhs.int64Value {
            return .int64(intOp(lInt, rInt))
        }
        if let lDouble = lhs.doubleValue, let rDouble = rhs.doubleValue {
            return .double(doubleOp(lDouble, rDouble))
        }
        throw RuntimeError(message: "unsupported numeric operands", symbolID: symbolID)
    }

    static func evaluateDivide(lhs: RuntimeValue?, rhs: RuntimeValue?, symbolID: SymbolID) throws -> RuntimeValue {
        guard let lhs, let rhs else {
            throw RuntimeError(message: "/ expects 2 operands", symbolID: symbolID)
        }
        if let lInt = lhs.int64Value, let rInt = rhs.int64Value {
            if rInt == 0 {
                throw RuntimeError(message: "division by zero", symbolID: symbolID)
            }
            return .int64(lInt / rInt)
        }
        if let lDouble = lhs.doubleValue, let rDouble = rhs.doubleValue {
            if rDouble == 0 {
                throw RuntimeError(message: "division by zero", symbolID: symbolID)
            }
            return .double(lDouble / rDouble)
        }
        throw RuntimeError(message: "unsupported / operands", symbolID: symbolID)
    }

    static func evaluateComparison(
        lhs: RuntimeValue?,
        rhs: RuntimeValue?,
        symbolID: SymbolID,
        comparator: (Double, Double) -> Bool
    ) throws -> RuntimeValue {
        guard let lhs, let rhs else {
            throw RuntimeError(message: "comparison expects 2 operands", symbolID: symbolID)
        }
        if let lDouble = lhs.doubleValue, let rDouble = rhs.doubleValue {
            return .bool(comparator(lDouble, rDouble))
        }
        if let lString = lhs.stringValue, let rString = rhs.stringValue {
            return .bool(comparator(Double(lString.count), Double(rString.count)))
        }
        throw RuntimeError(message: "unsupported comparison operands", symbolID: symbolID)
    }

    static func evaluateBoolOperator(
        lhs: RuntimeValue?,
        rhs: RuntimeValue?,
        symbolID: SymbolID,
        op: (Bool, Bool) -> Bool
    ) throws -> RuntimeValue {
        guard let lhs, let rhs else {
            throw RuntimeError(message: "boolean operator expects 2 operands", symbolID: symbolID)
        }
        guard let lhsBool = lhs.boolValue, let rhsBool = rhs.boolValue else {
            throw RuntimeError(message: "unsupported boolean operands", symbolID: symbolID)
        }
        return .bool(op(lhsBool, rhsBool))
    }
}

private extension Array {
    subscript(safe index: Int) -> Element? {
        guard indices.contains(index) else {
            return nil
        }
        return self[index]
    }
}
